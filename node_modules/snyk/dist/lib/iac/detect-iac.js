"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectType = void 0;
const fs = require("fs");
const pathLib = require("path");
const debugLib = require("debug");
const glob = require("glob");
const detect_1 = require("../detect");
const iac_parser_1 = require("./iac-parser");
const constants_1 = require("./constants");
const unsupported_options_iac_error_1 = require("../errors/unsupported-options-iac-error");
const invalid_iac_file_1 = require("../errors/invalid-iac-file");
const debug = debugLib('snyk-detect-iac');
async function getProjectType(root, options) {
    if (options.file) {
        debug('Iac - --file specified ' + options.file);
        throw unsupported_options_iac_error_1.UnsupportedOptionFileIacError(options.file);
    }
    if (detect_1.isLocalFolder(root)) {
        // Due to the fact we are first getting the project type and only then
        // scanning the projects - we need save the files we need to scan on the options
        // so we could create assembly payloads for the relevant files.
        // We are sending it as a `Multi IaC` project - and later assign the relevant type for each project
        const directoryFiles = await getDirectoryFiles(root);
        options.iacDirFiles = directoryFiles;
        return constants_1.IacProjectType.MULTI_IAC;
    }
    if (detect_1.localFileSuppliedButNotFound(root, '.') || !fs.existsSync(root)) {
        throw unsupported_options_iac_error_1.SupportLocalFileOnlyIacError();
    }
    const filePath = pathLib.resolve(root, '.');
    return getProjectTypeForIacFile(filePath);
}
exports.getProjectType = getProjectType;
async function getProjectTypeForIacFile(filePath) {
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const fileType = pathLib.extname(filePath).substr(1);
    const fileName = pathLib.basename(filePath);
    const projectType = constants_1.projectTypeByFileType[fileType];
    switch (projectType) {
        case constants_1.IacProjectType.K8S: {
            const { isValidFile, reason } = iac_parser_1.validateK8sFile(fileContent, filePath, fileName);
            if (!isValidFile) {
                throw invalid_iac_file_1.InvalidK8SFileError(reason);
            }
            break;
        }
        case constants_1.IacProjectType.TERRAFORM: {
            const { isValidFile, reason } = await iac_parser_1.makeValidateTerraformRequest(fileContent);
            if (!isValidFile) {
                throw invalid_iac_file_1.IllegalTerraformFileError([fileName], reason);
            }
            break;
        }
        default:
            throw invalid_iac_file_1.IllegalIacCustomError(fileName);
    }
    return projectType;
}
async function getDirectoryFiles(root) {
    const iacFiles = [];
    const dirPath = pathLib.resolve(root, '.');
    const files = glob.sync(pathLib.join(dirPath, '/**/**/*.+(json|yaml|yml|tf)'));
    for (const fileName of files) {
        const ext = pathLib.extname(fileName).substr(1);
        if (Object.keys(constants_1.projectTypeByFileType).includes(ext)) {
            const filePath = pathLib.resolve(root, fileName);
            await getProjectTypeForIacFile(filePath)
                .then((projectType) => {
                iacFiles.push({
                    filePath,
                    projectType,
                    fileType: ext,
                });
            })
                .catch((err) => {
                iacFiles.push({
                    filePath,
                    fileType: ext,
                    failureReason: err.userMessage,
                });
            });
        }
    }
    if (iacFiles.length === 0) {
        throw unsupported_options_iac_error_1.IacDirectoryWithoutAnyIacFileError();
    }
    return iacFiles;
}
//# sourceMappingURL=detect-iac.js.map